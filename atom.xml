<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>More Than Codes</title>
  
  <subtitle>怕什么真理无穷，进一步有进一步的欢喜。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-06T06:54:13.708Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>金成能</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>场景法测试用例设计</title>
    <link href="http://yoursite.com/2018/04/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E5%9C%BA%E6%99%AF%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/04/05/软件测试——基于场景的测试用例设计/</id>
    <published>2018-04-05T06:55:30.000Z</published>
    <updated>2018-04-06T06:54:13.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用场景法完成ATM的取款功能的测试用例设计。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>画出需要测试路径的流程图</li><li>分析基本流和备选流</li><li>根据基本流和备选流设计测试用例<a id="more"></a></li></ol><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://raw.githubusercontent.com/JinChengneng/images/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="基本事件流"><a href="#基本事件流" class="headerlink" title="基本事件流"></a>基本事件流</h3><ol><li>用户向ATM提款机中插入银行卡，如果银行卡是合法的，ATM提款机界面提示用户输入提款密码；(<strong>基本流1</strong>）</li><li>用户输入该银行卡的密码，如果输入密码正确，提示用户输入取钱金额；(<strong>基本流2</strong>）</li><li>用户输入取钱金额，如果输入的金额正确，且用户账户中有足够的余额，则向用户出款，并且减掉数据库中该用户帐户中的存款金额；(<strong>基本流3</strong>）</li><li>向用户询问是否需要其他操作，若不需要则退卡，并初始化系统状态。(<strong>基本流4</strong>）</li></ol><h3 id="备选事件流"><a href="#备选事件流" class="headerlink" title="备选事件流"></a>备选事件流</h3><ul><li>在基本事件流1中：<ol><li>如果插入无效的银行卡，那么在ATM提款机界面上提示用户，自动退出该银行卡，并重置到初始状态；（<strong>备选流1</strong>）</li></ol></li><li>在基本事件流2中：<ol><li>如果用户输入的密码错误，则提示用户密码输入错误，并引导用户重新输入；（<strong>备选流2</strong>）</li><li>如果用户连续3次输入错误密码，ATM提款机吞卡，并且ATM提款机的界面恢复到初始状态；（<strong>备选流3</strong>）</li><li>用户输入错误的密码且不超过三次，也可以手动退卡；（<strong>备选流4</strong>）</li></ol><ul><li>在基本事件流3中：<ol><li>如果用户输入的单笔提款金额超过单笔提款上限，ATM提款机界面提示输入金额错误，并引导重新输入； （<strong>备选流5</strong>）</li><li>如果用户输入的单笔金额，不是以100RMB为单位的，那么ATM提款机提示用户输入金额错误，并引导重新输入； （<strong>备选流6</strong>）</li><li>如果用户在24小时内提取的金额大于限额，则ATM提款机提示用户输入金额错误，并引导重新输入；（<strong>备选流7</strong>）</li><li>如果用户账户中余额不足，则提示用户账户中余额不足，并引导重新输入；（<strong>备选流8</strong>）</li><li>如果ATM提款机中余额不足，则提示用户ATM提款机中余额不足，并引导重新输入；（<strong>备选流9</strong>）</li></ol></li></ul></li><li>在基本事件流4中：<ol><li>如果用户选择进行其他操作，则跳转到操作选择页面；（<strong>备选流10</strong>）</li></ol></li></ul><h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><h3 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h3><table><thead><tr><th>场景序列</th><th style="text-align:center">基本流</th><th style="text-align:center">备选流</th></tr></thead><tbody><tr><td>场景1——成功取款</td><td style="text-align:center">1 2 3 4</td><td style="text-align:center">无</td></tr><tr><td>场景2——银行卡无法读取</td><td style="text-align:center">无</td><td style="text-align:center">1</td></tr><tr><td>场景3——密码输入错误但未超过三次</td><td style="text-align:center">1</td><td style="text-align:center">2 4</td></tr><tr><td>场景4——密码输入错误且达到三次</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td>场景5——用户输入提款金额超过单笔提款上限</td><td style="text-align:center">1 2</td><td style="text-align:center">5</td></tr><tr><td>场景6——用户输入金额不是整百数</td><td style="text-align:center">1 2</td><td style="text-align:center">6</td></tr><tr><td>场景7——用户24小时内提款金额超过当日限额</td><td style="text-align:center">1 2</td><td style="text-align:center">7</td></tr><tr><td>场景8——用户账户余额不足</td><td style="text-align:center">1 2</td><td style="text-align:center">8</td></tr><tr><td>场景9——ATM提款机中余额不足</td><td style="text-align:center">1 2</td><td style="text-align:center">9</td></tr><tr><td>场景10——用户取款成功后有其他操作需求</td><td style="text-align:center">1 2 3</td><td style="text-align:center">10</td></tr></tbody></table><h3 id="测试用例表"><a href="#测试用例表" class="headerlink" title="测试用例表"></a>测试用例表</h3><p>假设正确密码为0000.<br>|测试用例号|场景号|合法的银行卡|输入密码| 密码错误次数| 取款金额|当日取款限额|账户余额|取款机余额|预期结果|<br>| :——–: | :—–:| :—–: | :—-: | :—–: | :—-: |  :—–: | :—-: | :—-: |  :—-: |<br>|1 | 场景1——成功取款|是| 0000 | 0 | 100 | 10000 |  200|10000| 成功提款，账户余额被更新为100  |<br>|2 |场景2——银行卡无法读取 | 否 | / |  /| /  | / |/  |/| 无法获取账户信息，退回银行卡|<br>|3 | 场景3——密码输入错误但未超过三次 | 是 | 1111 |  1| /  |10000| / |/  |发送警告消息，返回基本流2|<br>|4 |场景4——密码输入错误且达到三次 | 是 | 1111 |  3| / |10000 | / |/  |发送警告消息，并吞卡|<br>|5 |场景5——用户输入提款金额超过单笔提款上限 | 是 | 0000 | 0| 20000  | 10000 |10000  |200000|发送提醒，并返回基本流3|<br>|6|场景6——用户输入金额不是整百数|是|0000|0|201.12|10000|10000|20000|发送提醒，并返回基本流3|<br>|7|场景7——用户24小时内提款金额超过限额|是|0000 | 0| 20000  | 10000 |10000  |200000|发送提醒，并返回基本流3|<br>|8|场景8——用户账户余额不足|是|0000 | 0| 20000  | 10000 |100  |200000|发送提醒，并返回基本流3|<br>|9|场景9——ATM提款机中余额不足|是|0000 | 0| 20000  | 10000 |10000  |2000|发送提醒，并返回基本流3|<br>|10|场景10——用户取款成功后有其他操作需求|是|0000|0|100|10000|200|10000|返回基本流2|</p><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>姓名：金成能 <br><br>学号：201530611838 <br><br>邮箱：jinchengneng@gmail.com <br><br>指导老师： 李红</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;用场景法完成ATM的取款功能的测试用例设计。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;画出需要测试路径的流程图&lt;/li&gt;
&lt;li&gt;分析基本流和备选流&lt;/li&gt;
&lt;li&gt;根据基本流和备选流设计测试用例
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【基础算法】刷题记录 2018-03-23</title>
    <link href="http://yoursite.com/2018/03/23/%E3%80%90%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2020180323/"/>
    <id>http://yoursite.com/2018/03/23/【基础算法】刷题记录 20180323/</id>
    <published>2018-03-23T06:17:48.000Z</published>
    <updated>2018-03-23T09:06:49.319Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最长回文子字符串</li><li>回文数字</li><li>最大多位数串</li><li>逆序整数</li></ul><a id="more"></a><h2 id="最长回文子字符串"><a href="#最长回文子字符串" class="headerlink" title="最长回文子字符串"></a>最长回文子字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个，在每个位置上平均大约要进行n/4次字符比较，于是此算法的时间复杂度是O(n^2)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max_len = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</div><div class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>)==s.charAt(i)))&#123;</div><div class="line">                len =<span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span>(len&gt;max_len)&#123;</div><div class="line">                    max_len = len;</div><div class="line">                    start = i;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">while</span>((i+len)&lt;s.length() &amp;&amp; i-len+<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; (s.charAt(i-len+<span class="number">1</span>) == s.charAt(i+len)))&#123;</div><div class="line">                    len++;</div><div class="line">                    <span class="keyword">if</span>(len*<span class="number">2</span>-<span class="number">2</span> &gt; max_len)&#123;</div><div class="line">                        max_len = len*<span class="number">2</span>-<span class="number">2</span>;</div><div class="line">                        start = i-len+<span class="number">2</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length())&#123;</div><div class="line">                len =<span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(i+len&lt;s.length() &amp;&amp; i-len&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i-len)==s.charAt(i+len))&#123;</div><div class="line">                    len++;</div><div class="line">                    <span class="keyword">if</span>((len*<span class="number">2</span>-<span class="number">1</span>)&gt;max_len)&#123;</div><div class="line">                        max_len = len*<span class="number">2</span> -<span class="number">1</span>;</div><div class="line">                        start = i-len+<span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s.substring(start, start+max_len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="回文数字"><a href="#回文数字" class="headerlink" title="回文数字"></a>回文数字</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Determine whether an integer is a palindrome. Do this without extra space.</p><h3 id="技巧点"><a href="#技巧点" class="headerlink" title="技巧点"></a>技巧点</h3><p>将原数字倒转一半，判断前一半数字是否相同</p><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>10及其倍数的处理</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> ||(x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">int</span> rx=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(x&gt;rx)&#123;</div><div class="line">            <span class="keyword">int</span> digit = x%<span class="number">10</span>;</div><div class="line">            x = x/<span class="number">10</span>;</div><div class="line">            rx = rx*<span class="number">10</span>+digit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(x==rx || x==rx/<span class="number">10</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="最大多位数串"><a href="#最大多位数串" class="headerlink" title="最大多位数串"></a>最大多位数串</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>设有n个正整数，将他们连接成一排，组成一个最大的多位整数。<br><br>如:n=3时，3个整数13,312,343,连成的最大整数为34331213。<br><br>如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题可以理解为对N个数进行排序，只不过排序的标准不是数值的大小，而是两个字符串组合到一起转化成整形后的数值大小。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> i, <span class="built_in">string</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (i+j)&gt;(j+i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;arr(n,<span class="string">""</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; n; i++)&#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i];</div><div class="line">        &#125;</div><div class="line">        sort(arr.begin(),arr.end(),compare);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>vector容器（构造函数参数，常用函数）</li><li>sort函数（algorithm头文件）</li></ol><h2 id="逆序整数"><a href="#逆序整数" class="headerlink" title="逆序整数"></a>逆序整数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a 32-bit signed integer, reverse digits of an integer.</p><h3 id="易错点-1"><a href="#易错点-1" class="headerlink" title="易错点"></a>易错点</h3><ol><li>负数的逆序</li><li>逆序后发生溢出<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rx=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> sign=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            sign = <span class="number">-1</span>;</div><div class="line">            x =-x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> digit = x%<span class="number">10</span>;</div><div class="line">            <span class="keyword">int</span> old_rx = rx;</div><div class="line">            rx = rx*<span class="number">10</span>+digit;</div><div class="line">            <span class="keyword">if</span>(rx/<span class="number">10</span> != old_rx)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                x = x/<span class="number">10</span>;</div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> rx*sign;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最长回文子字符串&lt;/li&gt;
&lt;li&gt;回文数字&lt;/li&gt;
&lt;li&gt;最大多位数串&lt;/li&gt;
&lt;li&gt;逆序整数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【基础算法】刷题记录 2018-03-13</title>
    <link href="http://yoursite.com/2018/03/13/%E3%80%90%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2020180313/"/>
    <id>http://yoursite.com/2018/03/13/【基础算法】刷题记录 20180313/</id>
    <published>2018-03-13T06:58:56.000Z</published>
    <updated>2018-03-13T07:46:41.606Z</updated>
    
    <content type="html"><![CDATA[<ul><li>二维数组中的查找</li><li>二分查找</li><li>连续子数组的最大和</li></ul><a id="more"></a><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找。当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> y = array[<span class="number">0</span>].length -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(x&lt;array[<span class="number">0</span>].length &amp;&amp; y&gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(array[x][y] &gt; target)&#123;</div><div class="line">                y -= <span class="number">1</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[x][y] &lt; target)&#123;</div><div class="line">                x += <span class="number">1</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。<br>给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。若该元素出现多次，请返回第一次出现的位置。</p><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>  [4,4,8,10] 4 4 按常规二分查找返回的是1，本题应返回的是0</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPos</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> right = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</div><div class="line">            <span class="keyword">int</span> current = (left+right)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(val &lt; A[current])&#123;</div><div class="line">                right = current -<span class="number">1</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; A[current])&#123;</div><div class="line">                left = current +<span class="number">1</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">while</span>(current &gt; <span class="number">0</span> &amp;&amp; A[current-<span class="number">1</span>] == A[current])&#123;</div><div class="line">                    current -= <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="连续最大和"><a href="#连续最大和" class="headerlink" title="连续最大和"></a>连续最大和</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>一个数组有 N 个元素，求连续子数组的最大和。 例如：[-1,2,1]，和最大的连续子数组为[2,1]，其和为 3 </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划。<br>如果用函数 f(i)表示以第 i 个数字结尾的子数组的最大和，那么我们需要求出 max[f(i)]，其中 0 &lt;= i &lt; n。我们可用如下边归公式求 f(i):</p><span>$$f(i)=\begin{cases}pData[i]&amp; \text{i=0 or f(i-1) &lt;= 0}\\f(i-1)+pData[i]&amp; \text{i!=0 and f(i-1)&gt;0}\end{cases}$$</span><!-- Has MathJax --><p>这个公式的意义：当以第 i-1 个数字结尾的子数组中所有数字的和小于 0 时，如果把这个负数与第 i 个数累加，得到的结果比第 i 个数字本身还要小，所以这种情况下以第 i 个数字结尾的子数组就是第 i 个数字本身。如果以第 i-1 个数字结尾的子数组中所有数字的和大于 0，与第 i 个数字累加就得到以第 i 个数字结尾的子数组中所有数字的和。</p><h3 id="易错点-1"><a href="#易错点-1" class="headerlink" title="易错点"></a>易错点</h3><p>很容易忽略全都是负数的情况，例如[-1,-2,-3,-4]。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="keyword">int</span> a[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> max =a[<span class="number">0</span>];</div><div class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</div><div class="line">        <span class="keyword">if</span>(curMax &lt; <span class="number">0</span>)&#123;</div><div class="line">            curMax =a[j];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            curMax += a[j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(max &lt; curMax)&#123;</div><div class="line">            max = curMax;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;max;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;二维数组中的查找&lt;/li&gt;
&lt;li&gt;二分查找&lt;/li&gt;
&lt;li&gt;连续子数组的最大和&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【面试经验】微信搜索推荐团队机器学习数据挖掘实习生</title>
    <link href="http://yoursite.com/2018/03/13/%E3%80%90%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E3%80%91%E5%BE%AE%E4%BF%A1%E6%90%9C%E7%B4%A2%E6%8E%A8%E8%8D%90%E5%9B%A2%E9%98%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    <id>http://yoursite.com/2018/03/13/【面试经验】微信搜索推荐团队机器学习数据挖掘实习生/</id>
    <published>2018-03-13T05:10:56.000Z</published>
    <updated>2018-03-13T06:02:38.409Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录了面试微信搜索推荐团队机器学习数据挖掘实习生(广州)过程中的问题，以供自己复习归纳和同方向的同学参考借鉴。</p><a id="more"></a><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><ul><li>你能在公司工作工作到几月？每星期能到岗多久？</li><li>你打算读研吗？</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>在一个经过排序的数组中插入一个数，返回该数的下标。（二分查找）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find the index of the insert position:  </div><div class="line">[1,3,5,9]  3   return 1</div><div class="line">[1,3,5,9]  0   return 0 </div><div class="line">[1,3,5,9]  40  return 4</div></pre></td></tr></table></figure><ul><li>找到一个数组中的最大和子数组。（动态规划）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find the subarray in a list has the largest sum</div><div class="line">[-2, 1,-3,4,-1,2,1,-5,4]  [4,-1,2,1]   has the biggest return 6</div></pre></td></tr></table></figure></li></ul><h2 id="机器学习和项目经验"><a href="#机器学习和项目经验" class="headerlink" title="机器学习和项目经验"></a>机器学习和项目经验</h2><ol><li>有哪些聚类方法？讲一下工作原理。</li><li>什么是过拟合？有哪些防止过拟合的方法？</li><li>有哪些正则化的方法？</li><li>有哪些降维的方法？你用过哪些？（深度学习和机器学习领域）</li><li>你了解L(1) L(2)吗？原理是什么？</li><li>机器学习有哪些常用的包？用过sklearn吗？</li><li>讲一个你喜欢的人工智能的现实应用。</li><li>你打的这几道赛题数据量是多少？有数据量大的项目经验吗？</li><li>项目里用过深度学习吗？RNN和LSTM有什么区别？LSTM的原理是什么？</li><li>linear regression和logistic regression的区别在哪里？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录了面试微信搜索推荐团队机器学习数据挖掘实习生(广州)过程中的问题，以供自己复习归纳和同方向的同学参考借鉴。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【TAIL CAMP】NLP Task：手写作文自动评分</title>
    <link href="http://yoursite.com/2018/02/10/TAIL%20CAMP%20NLP%20Task2/"/>
    <id>http://yoursite.com/2018/02/10/TAIL CAMP NLP Task2/</id>
    <published>2018-02-10T06:55:30.000Z</published>
    <updated>2018-02-10T07:00:42.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h2><ul><li>学习使用textblob</li><li>学习readability的计算方法和相关工具</li><li>自动作文评分理论与方法学习</li></ul><a id="more"></a><h2 id="Day-1-安装并学习使用-textblob-工具，学习parsing相关知识"><a href="#Day-1-安装并学习使用-textblob-工具，学习parsing相关知识" class="headerlink" title="Day 1: 安装并学习使用 textblob 工具，学习parsing相关知识"></a>Day 1: 安装并学习使用 textblob 工具，学习parsing相关知识</h2><p>  今天我们将学习使用另一个nlp常用工具textblob，通过使用这个工具，学习其中的Part-of-speech Tagging，Spelling Correction，n-gram等概念</p><ol><li>阅读<a href="http://www.nltk.org/book/ch08-extras.html" target="_blank" rel="external">nltk book 第八章节</a>，学习parsing概念</li></ol><ol><li>安装<a href="http://textblob.readthedocs.io/en/dev/install.html" target="_blank" rel="external">textblob</a></li></ol><ol><li>学习<a href="http://textblob.readthedocs.io/en/dev/quickstart.html#quickstart" target="_blank" rel="external">textblob功能点</a></li></ol><h2 id="Day2-学习Readability的定义和计算方法，学习使用工具textstat-和-readability。"><a href="#Day2-学习Readability的定义和计算方法，学习使用工具textstat-和-readability。" class="headerlink" title="Day2: 学习Readability的定义和计算方法，学习使用工具textstat 和 readability。"></a>Day2: 学习Readability的定义和计算方法，学习使用工具textstat 和 readability。</h2><p>今天我们学习nlp中文章可读性的定义和计算方法，同时会用工具去计算。文章的可读性在自动作文评分，分级阅读等领域都有应用。   </p><ol><li><p>学习<a href="https://en.wikipedia.org/wiki/Readability_test" target="_blank" rel="external">readability的定义</a></p></li><li><p>学习使用工具 <a href="https://pypi.python.org/pypi/textstat/" target="_blank" rel="external">textstat</a></p></li><li><p>学习使用工具 <a href="https://pypi.python.org/pypi/readability" target="_blank" rel="external">readability</a></p></li></ol><h2 id="Day3-学习Keras的安装和使用"><a href="#Day3-学习Keras的安装和使用" class="headerlink" title="Day3: 学习Keras的安装和使用"></a>Day3: 学习Keras的安装和使用</h2><p>今天我们学习Keras,掌握一种快速搭建和使用深度神经网络的工具，可选择用于后面建立基于深度学习的自动作文评分</p><ol><li><p>Keras 的介绍和安装 <a href="http://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="external">中文版本</a><br><a href="https://keras.io/#installation" target="_blank" rel="external">英文版本</a></p></li><li><p>学习使用keras <a href="http://keras-cn.readthedocs.io/en/latest/getting_started/sequential_model/" target="_blank" rel="external">中文教程</a></p></li></ol><ol><li>使用keras对文本进行处理和编码 <a href="https://keras-cn.readthedocs.io/en/latest/preprocessing/text/" target="_blank" rel="external">中文教程</a></li></ol><h2 id="Day4-amp-5-阅读论文，学习自动作文评分的理论和方法"><a href="#Day4-amp-5-阅读论文，学习自动作文评分的理论和方法" class="headerlink" title="Day4&amp;5: 阅读论文，学习自动作文评分的理论和方法"></a>Day4&amp;5: 阅读论文，学习自动作文评分的理论和方法</h2><p>前面几天我们已经学习了可以用来进行自动作文评分的一些概念和方法，接下来，我们通过阅读几片论文，了解和学习目前自动作文评分的主流的理论和方法。人工进行特征选择的方案，能够给写作文的用户带来更多的反馈信息，一定程度可以指导用户在弱项上进行提升；相比之下，基于深度学习的方法可能可以得到好的性能，但是是一个黑盒，从中没有办法获得更多的反馈；大家根据个人情况，可以充分发挥，例如做一些混合的系统等。以下内容作为同学们实现系统的参考：</p><p>参考阅读材料：</p><p><a href="https://www.researchgate.net/publication/278383803_Task-Independent_Features_for_Automated_Essay_Grading" target="_blank" rel="external">人工进行特征选择的评分系统</a></p><p><a href="http://www.aclweb.org/old_anthology/D/D16/D16-1193.pdf" target="_blank" rel="external">基于深度学习方法的评分系统</a></p><p>目前市面上比较权威的一个系统：<a href="https://www.ets.org/Media/Research/pdf/RR-04-45.pdf" target="_blank" rel="external">ETS的e-rater评分系统</a></p><h2 id="Day6-设计方案，进行机器自动评分"><a href="#Day6-设计方案，进行机器自动评分" class="headerlink" title="Day6: 设计方案，进行机器自动评分"></a>Day6: 设计方案，进行机器自动评分</h2><p>下面的链接是使用基于深度学习的方法进行作文自动评分的样例（前面提供论文的一个实现），可以作为一个实现方案的参考，同时大家可以自行设计自己的网络拓扑去做一些实验尝试。</p><p>此外，需要注意的是，我们选择的数据比样例少，所以考虑使用cpu模式去做实验，而样例使用了gpu模式。</p><p> <a href="https://github.com/nusnlp/nea" target="_blank" rel="external">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要目标&quot;&gt;&lt;a href=&quot;#主要目标&quot; class=&quot;headerlink&quot; title=&quot;主要目标&quot;&gt;&lt;/a&gt;主要目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;学习使用textblob&lt;/li&gt;
&lt;li&gt;学习readability的计算方法和相关工具&lt;/li&gt;
&lt;li&gt;自动作文评分理论与方法学习&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【TAIL CAMP】NLP Task：句子语义相似度预测</title>
    <link href="http://yoursite.com/2018/02/01/TAIL%20CAMP%20NLP%20Task1/"/>
    <id>http://yoursite.com/2018/02/01/TAIL CAMP NLP Task1/</id>
    <published>2018-02-01T06:54:29.000Z</published>
    <updated>2018-02-01T07:25:17.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h2><ul><li>学习nltk，gensim等基本自然语言处理工具</li><li>学习机器学习基本工具Sklearn</li><li>相似度计算理论与方法学习</li></ul><a id="more"></a><h2 id="Day1-nltk，python"><a href="#Day1-nltk，python" class="headerlink" title="Day1 nltk，python"></a>Day1 nltk，python</h2><p>学习使用nltk,python，同时掌握nlp的一些基本处理技巧和方法，例如tokenize，stem等</p><p>今天主要把推荐书籍的第五章节前面的内容，选择性看一遍（根据自身的情况选择），同时把里面涉及的python代码敲一敲(做文中的example)。主要学习python的数据类型和使用，以及nlp的一些基本概念。</p><ol><li><p>安装nltk <a href="http://www.nltk.org/install.html" target="_blank" rel="external">安装教程</a></p></li><li><p>学习<a href="http://www.nltk.org/book/" target="_blank" rel="external">《Natural Language Processing with Python》</a>一书前6章节，进行文本tokenize，stem等操作</p></li></ol><h2 id="Day-2-gensim"><a href="#Day-2-gensim" class="headerlink" title="Day 2: gensim"></a>Day 2: gensim</h2><p> 今天我们主要学习使用nlp中比较流行的一种词向量生成方法word2vec，gensim是其在python环境下的实现。除此之外，gensim本身还带有其他的一些例如特征提取，主题模型计算等功能</p><ol><li><p>安装gensim <a href="https://radimrehurek.com/gensim/install.html" target="_blank" rel="external">安装教程</a></p></li><li><p><a href="https://radimrehurek.com/gensim/tutorial.html" target="_blank" rel="external">Gensim主要功能介绍</a>，学习tf-idf提取等功能</p></li><li><p><a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="external">Gensim工具例子</a>: 学习使用gensim来提取，词向量等特征</p></li></ol><h2 id="Day3-scikit-learn"><a href="#Day3-scikit-learn" class="headerlink" title="Day3: scikit-learn"></a>Day3: scikit-learn</h2><p>scikit-learn安装和例子学习，学习使用工具进行拟合。</p><p>scikit-learn是机器学习领域广泛被使用的一个python工具，里面集成了大量的机器学习算法。今天我们学习其中的Ridge Regression 和 svr方法，Ridge Regression使用比较简单，svr是深度学习前的主流方法(里面现在也集成了深度学习的工具，有兴趣的同学可以尝试)。后面可以选择使用这些方法对相似度数据进行拟合。</p><ol><li><p><a href="http://scikit-learn.org/stable/" target="_blank" rel="external">官网主页</a></p></li><li><p><a href="http://scikit-learn.org/stable/install.html" target="_blank" rel="external">安装 scikit-learn 教程</a></p></li><li><p>学习使用 scikit-learn 进行拟合 </p><ul><li><a href="http://scikit-learn.org/stable/modules/linear_model.html#ridge-regression" target="_blank" rel="external">Ridge Regression教程</a>   </li><li><p><a href="http://scikit-learn.org/stable/modules/svm.html#regression" target="_blank" rel="external">Svr教程</a></p><p>说明：</p></li></ul><ol><li><p>若由于某些原因链接打不开，可以从主页点进去试试</p><p>Ridge Regression：主页 -&gt; Regression -&gt; 1.1.2 Ridge Regression</p><p>svr:  主页 -&gt; Regression -&gt; 1.4.2. Regression</p></li><li><p>对拟合概念不太理解的同学可参考：</p><p> <a href="https://zh.wikipedia.org/wiki/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88" target="_blank" rel="external">维基百科</a></p><p> <a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">Andrew Ng课程第三章</a></p></li></ol></li></ol><h2 id="Day4-amp-5-阅读论文，学习语义相似度计算的方法"><a href="#Day4-amp-5-阅读论文，学习语义相似度计算的方法" class="headerlink" title="Day4&amp;5:阅读论文，学习语义相似度计算的方法"></a>Day4&amp;5:阅读论文，学习语义相似度计算的方法</h2><p>前面几天已经学习了一些基本的工具和方法，接下来需要开始思考如何使用自己所学习到的内容（可以不在这几天的课程之类）来完成相似度预测的任务。以下几篇论文作为参考方法，可以采用提到的任意一种方法作为最终的实现方案，有余力的同学也可以实现多个方案。</p><p>参考阅读材料：</p><p>   <a href="http://nlp.arizona.edu/SemEval-2017/pdf/SemEval025.pdf" target="_blank" rel="external">http://nlp.arizona.edu/SemEval-2017/pdf/SemEval025.pdf</a></p><p>   <a href="http://www.aclweb.org/anthology/S/S14/S14-2039.pdf" target="_blank" rel="external">http://www.aclweb.org/anthology/S/S14/S14-2039.pdf</a></p><p>   <a href="http://nlp.arizona.edu/SemEval-2017/pdf/SemEval001.pdf" target="_blank" rel="external">http://nlp.arizona.edu/SemEval-2017/pdf/SemEval001.pdf</a></p><h2 id="Day6-参考方案，进行相似度预测"><a href="#Day6-参考方案，进行相似度预测" class="headerlink" title="Day6: 参考方案，进行相似度预测"></a>Day6: 参考方案，进行相似度预测</h2><p>   如果大家已经完成自己系统的搭建并提交预测数据，那么恭喜。如果没有，可以参考<a href="http://www.52nlp.cn/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%87%E6%A1%A3%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%BA%8C" target="_blank" rel="external">本链接</a> 中的做法，计算两个句子的相似度后再和人工的语义打分进行拟合。最后提交结果。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>主办方自诩难度比价高，任务量比较大，但这一论断应该是就新手而言。有过相关大数据与人工智能开发经验的人很多概念都应该已经掌握了，甚至能直接上手建模型了。事实情况也确实如此，任务发布三天半之后，超过一半的学员已经有过结果提交记录了，打榜也比较激烈，证明前期的学习难度确实不大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要目标&quot;&gt;&lt;a href=&quot;#主要目标&quot; class=&quot;headerlink&quot; title=&quot;主要目标&quot;&gt;&lt;/a&gt;主要目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;学习nltk，gensim等基本自然语言处理工具&lt;/li&gt;
&lt;li&gt;学习机器学习基本工具Sklearn&lt;/li&gt;
&lt;li&gt;相似度计算理论与方法学习&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【论文笔记】词向量的生成与语言模型(开发中...)</title>
    <link href="http://yoursite.com/2018/01/20/%E3%80%90%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91%E8%AF%8D%E5%90%91%E9%87%8F%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/01/20/【论文笔记】词向量的生成与语言模型/</id>
    <published>2018-01-20T09:31:32.000Z</published>
    <updated>2018-02-01T07:27:15.244Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客介绍了六种生成词向量的模型，分别是神经语言模型（NNLM）、对数双线性语言模型(LBLM)、C&amp;W模型、CBOW模型、skip-gram模型、（Order模型）、GloVe模型。</p><a id="more"></a><h2 id="神经语言模型（NNLM）"><a href="#神经语言模型（NNLM）" class="headerlink" title="神经语言模型（NNLM）"></a>神经语言模型（NNLM）</h2><p><img src="figure3.png" alt=""></p><p>Yoshua Bengio及其同事首先提出了一种同时学习词向量和语言模型的神经网络语言模型（NNLM）。 对于语料库中的每个样本，给出前面的词，我们使最后一个词的概率的对数似然最大化。 例如，对于语料库中的序列$w_1,w_2,…,w_n$，我们需要最大化$P(w_n|w_1,w<em>2,…,w</em>{n-1})$的对数似然性，其中我们把要预测的单词 $(w_n)$作为目标词。这个模型使用前面的词向量的串联作为输入：<br> <span>$$\begin{align}    \begin{split}        x=[e(w_1),...,e(w_{n-2}),e(w_{n-1})]    \end{split}\end{align}$$</span><!-- Has MathJax --></p><p> 模型结构是一个带有一个隐藏层的前馈神经网络：<br> <span>$$\begin{align}    \begin{split}        h &amp;= tanh(d + Hx) \\        y &amp;= b + Uh    \end{split}\end{align}$$</span><!-- Has MathJax --></p><p>其中$U$是变换矩阵，$b$和$d$是偏差向量。最后一步是应用softmax层来获得目标词的概率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客介绍了六种生成词向量的模型，分别是神经语言模型（NNLM）、对数双线性语言模型(LBLM)、C&amp;amp;W模型、CBOW模型、skip-gram模型、（Order模型）、GloVe模型。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【论文笔记】评价词向量性能的八个任务</title>
    <link href="http://yoursite.com/2018/01/18/%E3%80%90%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E3%80%91%E8%AF%84%E4%BB%B7%E8%AF%8D%E5%90%91%E9%87%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%AB%E4%B8%AA%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/01/18/【论文笔记】评价词向量性能的八个任务/</id>
    <published>2018-01-18T13:02:42.000Z</published>
    <updated>2018-01-18T13:10:27.509Z</updated>
    
    <content type="html"><![CDATA[<p>词向量的优劣可以从三个任务类型的八个任务进行综合评定。此篇博文简述了评价词向量性能的八个任务。</p><a id="more"></a><h2 id="语义属性（Sementic-Properties"><a href="#语义属性（Sementic-Properties" class="headerlink" title="语义属性（Sementic Properties)"></a>语义属性（Sementic Properties)</h2><h3 id="词语相似度（Word-Similarity）"><a href="#词语相似度（Word-Similarity）" class="headerlink" title="词语相似度（Word Similarity）"></a>词语相似度（Word Similarity）</h3><p>测试过程用的是WordSimilarity-353测试集，他包含353对英文词汇和人工对这些词对之间的语义相关度的评测值。词向量的效果比较的是两个词向量的余弦距离的Pearson相关性与人工打分的平均分数的相似程度。</p><h3 id="同义词选择题-Synonym-Question"><a href="#同义词选择题-Synonym-Question" class="headerlink" title="同义词选择题(Synonym Question)"></a>同义词选择题(Synonym Question)</h3><p>测试过程用的是托福考试中的80个同义词选择题，每道选择题有四个选项，选择问题与选项中余弦距离最近的选项，并评估最终整体的准确性。</p><h3 id="语义类比问题（Semantic-Analogy-Question）"><a href="#语义类比问题（Semantic-Analogy-Question）" class="headerlink" title="语义类比问题（Semantic Analogy Question）"></a>语义类比问题（Semantic Analogy Question）</h3><p>完成大约9000个语义类比问题，问题类似于“ man is to (woman) as king is to queen”。通过计算（queen-king+man）的最近词向量作为问题的答案，并评估整体的准确性。</p><h3 id="语法类比问题（Syntactic-Amalogy-Question）"><a href="#语法类比问题（Syntactic-Amalogy-Question）" class="headerlink" title="语法类比问题（Syntactic Amalogy Question）"></a>语法类比问题（Syntactic Amalogy Question）</h3><p>完成大约10500个语法类比问题，问题类似于“ predict is to (predicting) as dance is to dancing”, 通过计算（dancing - dance + predict）的最近词向量作为问题的答案，并评估整体的准确性。</p><h2 id="将词向量作为特征-Embedding-as-Features"><a href="#将词向量作为特征-Embedding-as-Features" class="headerlink" title="将词向量作为特征 (Embedding as Features)"></a>将词向量作为特征 (Embedding as Features)</h2><h3 id="文本分类-Text-Classification"><a href="#文本分类-Text-Classification" class="headerlink" title="文本分类 (Text Classification)"></a>文本分类 (Text Classification)</h3><p>使用词向量的加权平均值作为文本的表示，然后应用逻辑回归来执行文本分类。 每个单词的权重是其出现频率。使用的数据集是IMDB数据集。</p><h3 id="命名实体识别-Named-entity-recognization"><a href="#命名实体识别-Named-entity-recognization" class="headerlink" title="命名实体识别 (Named entity recognization)"></a>命名实体识别 (Named entity recognization)</h3><h2 id="用词向量初始化神经网络-Embedding-as-the-Initialization-of-Neural-Networks"><a href="#用词向量初始化神经网络-Embedding-as-the-Initialization-of-Neural-Networks" class="headerlink" title="用词向量初始化神经网络 (Embedding as the Initialization of Neural Networks)"></a>用词向量初始化神经网络 (Embedding as the Initialization of Neural Networks)</h2><p> 在最近的NLP任务的神经网络方法中，词向量被用来初始化第一层。</p><h3 id="句子情感分析-sentence-level-sentiment-classfication"><a href="#句子情感分析-sentence-level-sentiment-classfication" class="headerlink" title="句子情感分析 (sentence-level sentiment classfication)"></a>句子情感分析 (sentence-level sentiment classfication)</h3><p>使用卷积神经网络(CNN)在斯坦福情绪树库数据集上进行句子情感分类，重复实验五次，并展示这些实验的平均准确性。</p><h2 id="词性标注-Part-of-speech-Tagging"><a href="#词性标注-Part-of-speech-Tagging" class="headerlink" title="词性标注 (Part-of-speech Tagging)"></a>词性标注 (Part-of-speech Tagging)</h2><p>们使用Ronan Collobert及其同事提出的神经网络对华尔街日报数据进行词性标注，并评估准确性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;词向量的优劣可以从三个任务类型的八个任务进行综合评定。此篇博文简述了评价词向量性能的八个任务。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【机器学习】（开发中...）</title>
    <link href="http://yoursite.com/2017/11/18/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E3%80%81%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://yoursite.com/2017/11/18/【机器学习】线性分类、线性回归和梯度下降/</id>
    <published>2017-11-18T04:27:56.000Z</published>
    <updated>2018-01-18T13:21:14.153Z</updated>
    
    <content type="html"><![CDATA[<p>正在开发中…<br><a id="more"></a><br>$F_{\mu}$<br>$F_a + F_b = F_c$</p><p>$F_a = F_b + F_c + F_{\mu}$</p><p>公式是这样的 <span>$F_a = F_b + F_c + F_{\mu}$</span><!-- Has MathJax -->，你必须理解它，才能看懂下面这些公式：</p><span>$$\begin{aligned}\dot{x} &amp; = \sigma(y-x) \\\dot{y} &amp; = \rho x - y - xz \\\dot{z} &amp; = -\beta z + xy\end{aligned}$$</span><!-- Has MathJax --><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>进一步理解线性回归和梯度下降的原理。</li><li>在小规模数据集上实践。</li><li>体会优化和调参的过程。</li></ul><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li>线性回归使用的是LIBSVM Data中的Housing数据，包含506个样本，每个样本有13个属性。请自行下载scaled版本，并将其切分为训练集，验证集。 </li><li>线性分类使用的是LIBSVM Data中的australian数据，包含690个样本，每个样本有14 个属性。请自行下载scaled版本，并将其切分为训练集，验证集。</li></ul><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="线性回归和梯度下降"><a href="#线性回归和梯度下降" class="headerlink" title="线性回归和梯度下降"></a>线性回归和梯度下降</h3><ol><li>读取实验数据，使用sklearn库的load_svmlight_file函数读取数据。</li><li>将数据集切分为训练集和验证集，本次实验不切分测试集。使用train_test_split函数切分数据集。</li><li>线性模型参数初始化，可以考虑全零初始化，随机初始化或者正态分布初始化。<br>选择Loss函数及对其求导，过程详见课件ppt。<br>求得所有样本对Loss函数的梯度。<br>取梯度的负方向，记为。<br>更新模型参数，。为学习率，是人为调整的超参数。<br>在训练集上测试并得到Loss函数值，在验证集上测试并得到Loss函数值。<br>重复步骤5-8若干次，画出和随迭代次数的变化图。<br>$F$</li></ol><p>$$<br>\begin{eqnarray}<br>\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \<br>\nabla\cdot\vec{B} &amp;=&amp; 0 \<br>\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \<br>\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)<br>\end{eqnarray}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正在开发中…&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【基础定义】异构数据融合与共享项目基础定义总结</title>
    <link href="http://yoursite.com/2017/11/18/%E3%80%90%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89%E3%80%91%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/11/18/【基础定义】异构数据融合与共享基础定义总结/</id>
    <published>2017-11-18T04:27:56.000Z</published>
    <updated>2017-11-18T04:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP思想"><a href="#AOP思想" class="headerlink" title="AOP思想"></a>AOP思想</h2><p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。</p><a id="more"></a><p>refs：</p><ul><li><p><a href="https://baike.baidu.com/item/AOP/1332219?fr=aladdin" target="_blank" rel="external">AOP （面向切面编程）</a></p></li><li><p><a href="https://www.zhihu.com/question/24863332" target="_blank" rel="external">什么是面向切面编程AOP？</a></p></li></ul><h2 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h2><ul><li>Consistency(一致性), 数据一致更新，所有数据变动都是同步的</li><li>Availability(可用性), 好的响应性能</li><li>Partition tolerance(分区容错性) 可靠性</li></ul><p>定理：任何分布式系统只可同时满足二点，没法三者兼顾。</p><p>忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</p><p>refs:</p><ul><li><a href="http://www.jdon.com/37625" target="_blank" rel="external">CAP原理和BASE思想</a></li></ul><h2 id="ACID模型"><a href="#ACID模型" class="headerlink" title="ACID模型"></a>ACID模型</h2><p>关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：</p><ul><li>Atomicity 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。</li><li><p>Consistency 一致性. 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</p></li><li><p>Isolation 隔离性. 如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。事务将假定只有它自己在操作数据库，彼此不知晓。</p></li><li>Durability 持久性. 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li></ul><p>refs:</p><ul><li><a href="http://www.jdon.com/37625" target="_blank" rel="external">CAP原理和BASE思想</a></li><li><a href="https://baike.baidu.com/item/acid/10738?fr=aladdin" target="_blank" rel="external">acid （数据库事务正确执行的四个基本要素的缩写）</a></li></ul><h2 id="BASE思想"><a href="#BASE思想" class="headerlink" title="BASE思想"></a>BASE思想</h2><p>BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：</p><ul><li>Basically Available 基本可用。基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li><li>Soft state 软状态 状态可以有一段时间不同步，异步。软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。</li><li>Eventually consistent 最终一致，最终数据是一致的就可以了，而不是时时高一致。最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p><p>ACID和BASE代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p><p>refs:</p><ul><li><a href="http://www.jdon.com/37625" target="_blank" rel="external">CAP原理和BASE思想</a></li><li><a href="http://www.cnblogs.com/exceptioneye/p/5452601.html" target="_blank" rel="external">分布式系统的BASE理论</a></li></ul><h2 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h2><p>ASR：重要的架构需求，会对架构产生深远影响的需求；</p><p>ASR的几种获取方法：需求文档，采访利益相关者，理解商业目标，效应数；</p><h2 id="SOA模型"><a href="#SOA模型" class="headerlink" title="SOA模型"></a>SOA模型</h2><p>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。</p><p>SOA的精髓是严格的松散耦合，大家按照一个契约（service interface）来进行交流，不允许shared memory，不允许back door，不允许直接访问其它服务的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP思想&quot;&gt;&lt;a href=&quot;#AOP思想&quot; class=&quot;headerlink&quot; title=&quot;AOP思想&quot;&gt;&lt;/a&gt;AOP思想&lt;/h2&gt;&lt;p&gt;AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/p&gt;
&lt;p&gt;这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【项目笔记】iGEM wiki项目总结</title>
    <link href="http://yoursite.com/2017/11/08/iGEM-wiki/"/>
    <id>http://yoursite.com/2017/11/08/iGEM-wiki/</id>
    <published>2017-11-08T12:05:14.000Z</published>
    <updated>2017-11-08T11:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>该项目是为SCUT—China_A队伍制作wiki主页。项目比较简单，就是用基本的HTML+CSS+JavaScript写一个网站，大约有20个页面。页面设计是扁平化的极简风格的三栏式布局。项目因为一直没有收到设计稿，项目无法进行，最终在wiki freeze前四天正式开始编码，用时近两天半完成了整个网站的制作。开发过程中基本采用敏捷式开发方法，跟设计组采用流水线的工作形式，迭代开发每一个网页。</p><h2 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h2><p><a href="http://2017.igem.org/Team:SCUT-China_A" target="_blank" rel="external">http://2017.igem.org/Team:SCUT-China_A</a></p><a id="more"></a><h2 id="项目收获"><a href="#项目收获" class="headerlink" title="项目收获"></a>项目收获</h2><ul><li>重新熟悉了基础的前端语法</li><li>所在的队伍极有可能拿到一个国际级奖项</li><li>认识了一群非常可爱而优秀的小伙伴</li></ul><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><ul><li>iGEM官方提供了服务器，这减少了搭建网站的工作量，但官方提供的代码编辑器非常难用，而且默认模板样式很诡异，而且会覆盖所提及网页的样式，需要自己再重新把平台覆盖的样式覆盖掉。</li><li>wiki tools平台会先解析一遍上传的代码，并做出一些匪夷所思的更改，比如说把 &amp;&amp; 替换成 &amp;amp ;&amp;amp ;。这个问题怀疑是平台传输代码数据时造成的更改，但一时间难以找到真正原因，所以采取的解决办法就是用嵌套选择语句代替&amp;&amp;语句。</li><li>设计组的设计稿交付不及时，这导致严重的项目赶工情况的发生。编码的那两天半里每天熬夜到三四点，以后一定要催促设计组及时交付文档。</li><li>项目难度不大，但是工作量大，基本是重复性的搬砖工作。所以将图片上传等简单的工作交给其他人来完成，并且教会了一至两个人写简单的HTML代码，这大大减少了我的工作量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目描述&quot;&gt;&lt;a href=&quot;#项目描述&quot; class=&quot;headerlink&quot; title=&quot;项目描述&quot;&gt;&lt;/a&gt;项目描述&lt;/h2&gt;&lt;p&gt;该项目是为SCUT—China_A队伍制作wiki主页。项目比较简单，就是用基本的HTML+CSS+JavaScript写一个网站，大约有20个页面。页面设计是扁平化的极简风格的三栏式布局。项目因为一直没有收到设计稿，项目无法进行，最终在wiki freeze前四天正式开始编码，用时近两天半完成了整个网站的制作。开发过程中基本采用敏捷式开发方法，跟设计组采用流水线的工作形式，迭代开发每一个网页。&lt;/p&gt;
&lt;h2 id=&quot;项目成果&quot;&gt;&lt;a href=&quot;#项目成果&quot; class=&quot;headerlink&quot; title=&quot;项目成果&quot;&gt;&lt;/a&gt;项目成果&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://2017.igem.org/Team:SCUT-China_A&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://2017.igem.org/Team:SCUT-China_A&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【解决方案】robo3t 1.1在ubuntu 16.04中无法打开的解决方案</title>
    <link href="http://yoursite.com/2017/08/10/16-04%E4%B8%AD%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/08/10/16-04中无法打开的解决方案/</id>
    <published>2017-08-10T00:27:56.000Z</published>
    <updated>2018-02-01T07:42:33.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>robo3t 1.1在ubuntu 16.04中无法打开，具体表现为双击robo3t可执行文件无反应，用终端 ./robo3t 命令报错为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">This application failed to start because it could not find or load the Qt platform plugin &quot;xcb&quot;</div><div class="line">in &quot;&quot;.</div><div class="line"></div><div class="line">Available platform plugins are: xcb.</div><div class="line"></div><div class="line">Reinstalling the application may fix this problem.</div><div class="line">已放弃 (核心已转储)</div></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>删除lib中的libstdc++*</p><a id="more"></a><p> 按顺序执行这三句命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir ~/robo-backup</div><div class="line">mv robo3t-1.1.1-linux-x86_64-c93c6b0/lib/libstdc++* ~/robo-backup/</div><div class="line">robo3t-1.1.1-linux-x86_64-c93c6b0/bin/robo3t</div></pre></td></tr></table></figure><p>即可完美解决该问题</p><p>ref：<a href="https://github.com/Studio3T/robomongo/issues/1385" target="_blank" rel="external">https://github.com/Studio3T/robomongo/issues/1385</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;robo3t 1.1在ubuntu 16.04中无法打开，具体表现为双击robo3t可执行文件无反应，用终端 ./robo3t 命令报错为&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;This application failed to start because it could not find or load the Qt platform plugin &amp;quot;xcb&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;in &amp;quot;&amp;quot;.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Available platform plugins are: xcb.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Reinstalling the application may fix this problem.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;已放弃 (核心已转储)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;删除lib中的libstdc++*&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【解决方案】Chrome更新至58.0后XX.net无法使用，提示“请检查浏览器代理设置”的解决方案</title>
    <link href="http://yoursite.com/2017/05/26/Chrome%E6%9B%B4%E6%96%B0%E8%87%B358-0%E5%90%8EXX-net%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%8F%90%E7%A4%BA%E2%80%9C%E8%AF%B7%E6%A3%80%E6%9F%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/05/26/Chrome更新至58-0后XX-net无法使用，提示“请检查浏览器代理设置”的解决方案/</id>
    <published>2017-05-26T07:24:53.000Z</published>
    <updated>2018-02-01T07:42:22.254Z</updated>
    
    <content type="html"><![CDATA[<p>chrome 更新至58.0后，部分用户会发现xx-net无法使用，并提示“请检查浏览器代理设置”，且日志中反复出现 con failed（连接失败），解决方法如下：</p><p>1.将xx-net更新至测试版3.3.2或者稳定版3.3.1<br>下载地址： <a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="external">https://github.com/XX-net/XX-Net/blob/master/code/default/download.md</a><br>2.删除安装文件夹/data/gae_proxy文件夹下的certs文件夹和CA.crt文件<br>3.在Chrome游览器的设置中删除已导入的xx-net的证书，删除方法参考官方文档<a href="https://github.com/XX-net/XX-Net/wiki/%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF" target="_blank" rel="external">https://github.com/XX-net/XX-Net/wiki/%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF</a><br>（删除后，如有必要请重新手动添加证书，不过大多数情况下该步骤都能自动完成）<br>4.检查SwitchyOmega的代理设置（如果没有更改过可跳过该步骤）<br>5.启动xx-net，如无意外，xx-net可正常运行<br>（升级xx-net可能需要重新部署服务端并配置，可参考官方文档<a href="https://github.com/XX-net/XX-Net/wiki/how-to-create-my-appids" target="_blank" rel="external">https://github.com/XX-net/XX-Net/wiki/how-to-create-my-appids</a> ）</p><p>如有疑问，请留言讨论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;chrome 更新至58.0后，部分用户会发现xx-net无法使用，并提示“请检查浏览器代理设置”，且日志中反复出现 con failed（连接失败），解决方法如下：&lt;/p&gt;
&lt;p&gt;1.将xx-net更新至测试版3.3.2或者稳定版3.3.1&lt;br&gt;下载地址： &lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【LeetCode刷题记录】9. Palindrome Number</title>
    <link href="http://yoursite.com/2017/04/26/Number/"/>
    <id>http://yoursite.com/2017/04/26/Number/</id>
    <published>2017-04-26T14:25:30.000Z</published>
    <updated>2017-11-08T11:46:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Determine whether an integer is a palindrome. Do this without extra space.</p><p>这道题目实现并不难，但题目要求空间复杂度为O(1), 有一定的技巧性。</p><h1 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h1><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> palindromeX = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> inputX = x;</div><div class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</div><div class="line">            palindromeX = palindromeX*<span class="number">10</span> + (x % <span class="number">10</span>);</div><div class="line">            x = x/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> palindromeX==inputX;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>受到LeetCode 7.Reverse Integer 的启发，将原int型的数据完全反转后，比较反转后的数据与原数据是否相同，相同则为回文，反之不是。</p><a id="more"></a><p>Question：这个算法没有考虑到int型数据反转后可能存在的溢出情况，是不是有错误？<br>Answer: 若反转后的数据比原数据大，那么它一定与原数据不相同，肯定不是回文了，所以这个算法隐性地排除了溢出的情况。</p><p>但进一步思考，判断是否为回文需要将整个数字完全反转吗？反转到一半不久可以进行比较了吗？这就引出了Solution 2。</p><!-- more --><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>|| (x!=<span class="number">0</span> &amp;&amp;x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(x&gt;sum)</div><div class="line">        &#123;</div><div class="line">            sum = sum*<span class="number">10</span>+x%<span class="number">10</span>;</div><div class="line">            x = x/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (x==sum)||(x==sum/<span class="number">10</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这个算法要额外考虑能被10整除的数，需要特别注意。</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3:"></a>Solution 3:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">          <span class="comment">//negative number</span></div><div class="line">          <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</div><div class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">              </div><div class="line">          <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">         <span class="keyword">while</span>(x / len &gt;= <span class="number">10</span>)</div><div class="line">             len *= <span class="number">10</span>;</div><div class="line">             </div><div class="line">         <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;  </div><div class="line">             <span class="comment">//get the head and tail number</span></div><div class="line">             <span class="keyword">int</span> left = x / len;</div><div class="line">             <span class="keyword">int</span> right = x % <span class="number">10</span>;</div><div class="line">             </div><div class="line">             <span class="keyword">if</span>(left != right)</div><div class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">             <span class="keyword">else</span>&#123;</div><div class="line">                 <span class="comment">//remove the head and tail number</span></div><div class="line">                 x = (x % len) / <span class="number">10</span>;</div><div class="line">                 len /= <span class="number">100</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;       </div><div class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure><p>解题思路： 每次提取头尾两个数，判断它们是否相等，判断后去掉头尾两个数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description:&quot;&gt;&lt;/a&gt;Description:&lt;/h1&gt;&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;/p&gt;
&lt;p&gt;这道题目实现并不难，但题目要求空间复杂度为O(1), 有一定的技巧性。&lt;/p&gt;
&lt;h1 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h1&gt;&lt;h2 id=&quot;Solution-1&quot;&gt;&lt;a href=&quot;#Solution-1&quot; class=&quot;headerlink&quot; title=&quot;Solution 1:&quot;&gt;&lt;/a&gt;Solution 1:&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; boolean &lt;span class=&quot;title&quot;&gt;isPalindrome&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; palindromeX = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; inputX = x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(x&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            palindromeX = palindromeX*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + (x % &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            x = x/&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; palindromeX==inputX;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;受到LeetCode 7.Reverse Integer 的启发，将原int型的数据完全反转后，比较反转后的数据与原数据是否相同，相同则为回文，反之不是。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【LeetCode刷题记录】7.Reverse Integer</title>
    <link href="http://yoursite.com/2017/04/25/Integer/"/>
    <id>http://yoursite.com/2017/04/25/Integer/</id>
    <published>2017-04-25T12:05:14.000Z</published>
    <updated>2017-11-06T04:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h1><p>Reverse digits of an integer.</p><p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p><p>Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p><p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p><p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p><p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>Note:<br>The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.</p><p>解体思路：这道题目比较简单，难点在于溢出的判断与处理。</p><a id="more"></a><h1 id="Solutions："><a href="#Solutions：" class="headerlink" title="Solutions："></a>Solutions：</h1><h2 id="Solutions-1："><a href="#Solutions-1：" class="headerlink" title="Solutions 1："></a>Solutions 1：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int reverse(int x) &#123;  </div><div class="line">        const int max = 0x7fffffff;  //int最大值  </div><div class="line">        const int min = 0x80000000;  //int最小值  </div><div class="line">        long long sum = 0;   </div><div class="line">          </div><div class="line">        while(x != 0)  </div><div class="line">        &#123;  </div><div class="line">            int temp = x % 10;  </div><div class="line">            sum = sum * 10 + temp;  </div><div class="line">            if (sum &gt; max || sum &lt; min)   //溢出处理  </div><div class="line">            &#123;  </div><div class="line">                sum = sum &gt; 0 ? max : min;    </div><div class="line">                return sum;  </div><div class="line">            &#125;  </div><div class="line">            x = x / 10;  </div><div class="line">        &#125;  </div><div class="line">        return sum;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>将int数据类型能表示的最大值与最小值用十六进制表示出来，虽然有效，但是代码里0x7fffffff这种 hard code 不够优雅，而且容易出错。</p><h2 id="Improved-Solution-1"><a href="#Improved-Solution-1" class="headerlink" title="Improved Solution 1:"></a>Improved Solution 1:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public int reverse(int x) &#123;</div><div class="line">        long rev= 0;</div><div class="line">        while( x != 0)&#123;</div><div class="line">            rev= rev*10 + x % 10;</div><div class="line">            x= x/10;</div><div class="line">            if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE)</div><div class="line">                return 0;</div><div class="line">        &#125;</div><div class="line">        return (int) rev;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>int数据类型能表现的上下限以 Integer.MAX_VALUE 和 Integer.MIN_VALUE 表示，更加优雅简洁。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public int reverse(int x)</div><div class="line">&#123;</div><div class="line">    int result = 0;</div><div class="line"></div><div class="line">    while (x != 0)</div><div class="line">    &#123;</div><div class="line">        int tail = x % 10;</div><div class="line">        int newResult = result * 10 + tail;</div><div class="line">        if ((newResult - tail) / 10 != result)</div><div class="line">        &#123; return 0; &#125;</div><div class="line">        result = newResult;</div><div class="line">        x = x / 10;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>原理： If overflow exists, the new result will not equal to the previous one.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description:&quot;&gt;&lt;/a&gt;Description:&lt;/h1&gt;&lt;p&gt;Reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;Example1: x = 123, return 321&lt;br&gt;Example2: x = -123, return -321&lt;/p&gt;
&lt;p&gt;Have you thought about this?&lt;br&gt;Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!&lt;/p&gt;
&lt;p&gt;If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.&lt;/p&gt;
&lt;p&gt;Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?&lt;/p&gt;
&lt;p&gt;For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.&lt;/p&gt;
&lt;p&gt;解体思路：这道题目比较简单，难点在于溢出的判断与处理。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【LeetCode刷题记录】1.Two Sum解法与Hashmap的应用</title>
    <link href="http://yoursite.com/2017/04/24/Sum%E8%A7%A3%E6%B3%95%E4%B8%8EHashmap%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/04/24/Sum解法与Hashmap的应用/</id>
    <published>2017-04-24T06:44:59.000Z</published>
    <updated>2017-11-06T04:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><p>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</p><a id="more"></a><h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution:"></a>My solution:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target &amp;&amp; i!=j)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;i, j&#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Runtime：56ms<br>Your runtime beats 9.43% of java submissions.</p></blockquote><p>显然时间复杂度为O(n^2)，耗时太长，不太合理。</p><h2 id="Better-Solutions"><a href="#Better-Solutions" class="headerlink" title="Better Solutions:"></a>Better Solutions:</h2><p>以下为其他人提交的时间复杂度为O(n)的算法。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//Key is the number and value is its index in the vector.</span></div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</div><div class="line"><span class="keyword">int</span> numberToFind = target - numbers[i];</div><div class="line"></div><div class="line">            <span class="comment">//if numberToFind is found in map, return them</span></div><div class="line"><span class="keyword">if</span> (hash.find(numberToFind) != hash.end()) &#123;</div><div class="line">                    <span class="comment">//+1 because indices are NOT zero based</span></div><div class="line">result.push_back(hash[numberToFind] + <span class="number">1</span>);</div><div class="line">result.push_back(i + <span class="number">1</span>);</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">            <span class="comment">//number was not found. Put it in the map.</span></div><div class="line">hash[numbers[i]] = i;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (map.containsKey(target - numbers[i])) &#123;</div><div class="line">            result[<span class="number">1</span>] = i + <span class="number">1</span>;</div><div class="line">            result[<span class="number">0</span>] = map.get(target - numbers[i]);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        map.put(numbers[i], i + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Maybe-The-Shorest-Solution"><a href="#Maybe-The-Shorest-Solution" class="headerlink" title="Maybe The Shorest Solution"></a>Maybe The Shorest Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    HashMap&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(target - nums[i])) </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="built_in">map</span>.get(target - nums[i]) + <span class="number">1</span>, i + <span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">else</span> <span class="built_in">map</span>.put(nums[i], i);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h1 id="为什么要用Hashmap？"><a href="#为什么要用Hashmap？" class="headerlink" title="为什么要用Hashmap？"></a>为什么要用Hashmap？</h1><p>Hashmap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，为了将时间复杂度降到O(n)，我们使用了Hashmap。</p><h2 id="methods-of-Hashmap"><a href="#methods-of-Hashmap" class="headerlink" title="methods of Hashmap"></a>methods of Hashmap</h2><ul><li>HashMap() <pre><code>构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</code></pre></li><li>HashMap(int initialCapacity) <pre><code>构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap </code></pre></li><li>HashMap(int initialCapacity, float loadFactor) <pre><code>构造一个带指定初始容量和加载因子的空 HashMap</code></pre></li><li>void    clear() <pre><code>从此映射中移除所有映射关系。</code></pre></li><li>boolean    containsKey(Object key) <pre><code>如果此映射包含对于指定的键的映射关系，则返回 true。</code></pre></li><li>boolean    containsValue(Object value) <pre><code>如果此映射将一个或多个键映射到指定值，则返回 true。</code></pre></li><li>V    put(K key, V value) <pre><code>在此映射中关联指定值与指定键。-</code></pre></li></ul><p>在HashMap中通过get()来获取value，通过put()来插入value，ContainsKey()则用来检验对象是否已经存在。可以看出，和ArrayList的操作相比，HashMap除了通过key索引其内容之外，别的方面差异并不大。</p><p>使用HashMap后，运行速度相比于原来的275ms确实有明显提升</p><blockquote><p>Runtime: 8ms<br>Your runtime beats 56.48% of java submissions. </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description:&quot;&gt;&lt;/a&gt;Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;
&lt;h2 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example:&quot;&gt;&lt;/a&gt;Example:&lt;/h2&gt;&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
