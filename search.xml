<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【基础定义】异构数据融合与共享项目基础定义总结]]></title>
    <url>%2F2017%2F11%2F18%2F%E3%80%90%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89%E3%80%91%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AOP思想AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。 refs： AOP （面向切面编程） 什么是面向切面编程AOP？ CAP原理 Consistency(一致性), 数据一致更新，所有数据变动都是同步的 Availability(可用性), 好的响应性能 Partition tolerance(分区容错性) 可靠性 定理：任何分布式系统只可同时满足二点，没法三者兼顾。 忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。 refs: CAP原理和BASE思想 ACID模型关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区： Atomicity 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。 Consistency 一致性. 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。 Isolation 隔离性. 如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。事务将假定只有它自己在操作数据库，彼此不知晓。 Durability 持久性. 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 refs: CAP原理和BASE思想 acid （数据库事务正确执行的四个基本要素的缩写） BASE思想BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： Basically Available 基本可用。基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。 Soft state 软状态 状态可以有一段时间不同步，异步。软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。 Eventually consistent 最终一致，最终数据是一致的就可以了，而不是时时高一致。最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。 ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。 ACID和BASE代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。 refs: CAP原理和BASE思想 分布式系统的BASE理论 ASRASR：重要的架构需求，会对架构产生深远影响的需求； ASR的几种获取方法：需求文档，采访利益相关者，理解商业目标，效应数； SOA模型面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。 SOA的精髓是严格的松散耦合，大家按照一个契约（service interface）来进行交流，不允许shared memory，不允许back door，不允许直接访问其它服务的数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【机器学习】]]></title>
    <url>%2F2017%2F11%2F18%2F%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E3%80%81%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[$F_{\mu}$$F_a + F_b = F_c$ $F_a = F_b + F_c + F_{\mu}$ 公式是这样的 $F_a = F_b + F_c + F_{\mu}$，你必须理解它，才能看懂下面这些公式： $$\begin{aligned} \dot{x} &amp; = \sigma(y-x) \\ \dot{y} &amp; = \rho x - y - xz \\ \dot{z} &amp; = -\beta z + xy \end{aligned}$$ 实验目的 进一步理解线性回归和梯度下降的原理。 在小规模数据集上实践。 体会优化和调参的过程。 数据集 线性回归使用的是LIBSVM Data中的Housing数据，包含506个样本，每个样本有13个属性。请自行下载scaled版本，并将其切分为训练集，验证集。 线性分类使用的是LIBSVM Data中的australian数据，包含690个样本，每个样本有14 个属性。请自行下载scaled版本，并将其切分为训练集，验证集。 实验步骤线性回归和梯度下降 读取实验数据，使用sklearn库的load_svmlight_file函数读取数据。 将数据集切分为训练集和验证集，本次实验不切分测试集。使用train_test_split函数切分数据集。 线性模型参数初始化，可以考虑全零初始化，随机初始化或者正态分布初始化。选择Loss函数及对其求导，过程详见课件ppt。求得所有样本对Loss函数的梯度。取梯度的负方向，记为。更新模型参数，。为学习率，是人为调整的超参数。在训练集上测试并得到Loss函数值，在验证集上测试并得到Loss函数值。重复步骤5-8若干次，画出和随迭代次数的变化图。$F$ $$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\nabla\cdot\vec{B} &amp;=&amp; 0 \\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[【项目笔记】iGEM wiki项目总结]]></title>
    <url>%2F2017%2F11%2F08%2FiGEM-wiki%2F</url>
    <content type="text"><![CDATA[项目描述该项目是为SCUT—China_A队伍制作wiki主页。项目比较简单，就是用基本的HTML+CSS+JavaScript写一个网站，大约有20个页面。页面设计是扁平化的极简风格的三栏式布局。项目因为一直没有收到设计稿，项目无法进行，最终在wiki freeze前四天正式开始编码，用时近两天半完成了整个网站的制作。开发过程中基本采用敏捷式开发方法，跟设计组采用流水线的工作形式，迭代开发每一个网页。 项目成果http://2017.igem.org/Team:SCUT-China_A 项目收获 重新熟悉了基础的前端语法 所在的队伍极有可能拿到一个国际级奖项 认识了一群非常可爱而优秀的小伙伴 项目难点 iGEM官方提供了服务器，这减少了搭建网站的工作量，但官方提供的代码编辑器非常难用，而且默认模板样式很诡异，而且会覆盖所提及网页的样式，需要自己再重新把平台覆盖的样式覆盖掉。 wiki tools平台会先解析一遍上传的代码，并做出一些匪夷所思的更改，比如说把 &amp;&amp; 替换成 &amp;amp ;&amp;amp ;。这个问题怀疑是平台传输代码数据时造成的更改，但一时间难以找到真正原因，所以采取的解决办法就是用嵌套选择语句代替&amp;&amp;语句。 设计组的设计稿交付不及时，这导致严重的项目赶工情况的发生。编码的那两天半里每天熬夜到三四点，以后一定要催促设计组及时交付文档。 项目难度不大，但是工作量大，基本是重复性的搬砖工作。所以将图片上传等简单的工作交给其他人来完成，并且教会了一至两个人写简单的HTML代码，这大大减少了我的工作量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[robo3t 1.1在ubuntu 16.04中无法打开的解决方案]]></title>
    <url>%2F2017%2F08%2F10%2F16-04%E4%B8%AD%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[问题描述robo3t 1.1在ubuntu 16.04中无法打开，具体表现为双击robo3t可执行文件无反应，用终端 ./robo3t 命令报错为 1234567This application failed to start because it could not find or load the Qt platform plugin &quot;xcb&quot;in &quot;&quot;.Available platform plugins are: xcb.Reinstalling the application may fix this problem.已放弃 (核心已转储) 解决方案删除lib中的libstdc++* 按顺序执行这三句命令： 123mkdir ~/robo-backupmv robo3t-1.1.1-linux-x86_64-c93c6b0/lib/libstdc++* ~/robo-backup/robo3t-1.1.1-linux-x86_64-c93c6b0/bin/robo3t 即可完美解决该问题 ref：https://github.com/Studio3T/robomongo/issues/1385]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome更新至58.0后XX.net无法使用，提示“请检查浏览器代理设置”的解决方案]]></title>
    <url>%2F2017%2F05%2F26%2FChrome%E6%9B%B4%E6%96%B0%E8%87%B358-0%E5%90%8EXX-net%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%8F%90%E7%A4%BA%E2%80%9C%E8%AF%B7%E6%A3%80%E6%9F%A5%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[chrome 更新至58.0后，部分用户会发现xx-net无法使用，并提示“请检查浏览器代理设置”，且日志中反复出现 con failed（连接失败），解决方法如下： 1.将xx-net更新至测试版3.3.2或者稳定版3.3.1下载地址： https://github.com/XX-net/XX-Net/blob/master/code/default/download.md2.删除安装文件夹/data/gae_proxy文件夹下的certs文件夹和CA.crt文件3.在Chrome游览器的设置中删除已导入的xx-net的证书，删除方法参考官方文档https://github.com/XX-net/XX-Net/wiki/%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF（删除后，如有必要请重新手动添加证书，不过大多数情况下该步骤都能自动完成）4.检查SwitchyOmega的代理设置（如果没有更改过可跳过该步骤）5.启动xx-net，如无意外，xx-net可正常运行（升级xx-net可能需要重新部署服务端并配置，可参考官方文档https://github.com/XX-net/XX-Net/wiki/how-to-create-my-appids ） 如有疑问，请留言讨论]]></content>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode刷题记录】9. Palindrome Number]]></title>
    <url>%2F2017%2F04%2F26%2FNumber%2F</url>
    <content type="text"><![CDATA[Description:Determine whether an integer is a palindrome. Do this without extra space. 这道题目实现并不难，但题目要求空间复杂度为O(1), 有一定的技巧性。 Solutions:Solution 1:123456789public boolean isPalindrome(int x) &#123; int palindromeX = 0; int inputX = x; while(x&gt;0)&#123; palindromeX = palindromeX*10 + (x % 10); x = x/10; &#125; return palindromeX==inputX; &#125; 受到LeetCode 7.Reverse Integer 的启发，将原int型的数据完全反转后，比较反转后的数据与原数据是否相同，相同则为回文，反之不是。 Question：这个算法没有考虑到int型数据反转后可能存在的溢出情况，是不是有错误？Answer: 若反转后的数据比原数据大，那么它一定与原数据不相同，肯定不是回文了，所以这个算法隐性地排除了溢出的情况。 但进一步思考，判断是否为回文需要将整个数字完全反转吗？反转到一半不久可以进行比较了吗？这就引出了Solution 2。 Solution 2:12345678910bool isPalindrome(int x) &#123; if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false; int sum=0; while(x&gt;sum) &#123; sum = sum*10+x%10; x = x/10; &#125; return (x==sum)||(x==sum/10); &#125; 这个算法要额外考虑能被10整除的数，需要特别注意。 Solution 3:123456789101112131415161718192021222324bool isPalindrome(int x) &#123; //negative number if(x &lt; 0) return false; int len = 1; while(x / len &gt;= 10) len *= 10; while(x &gt; 0) &#123; //get the head and tail number int left = x / len; int right = x % 10; if(left != right) return false; else&#123; //remove the head and tail number x = (x % len) / 10; len /= 100; &#125; &#125; return true; &#125; 解题思路： 每次提取头尾两个数，判断它们是否相等，判断后去掉头尾两个数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode刷题记录】7.Reverse Integer]]></title>
    <url>%2F2017%2F04%2F25%2FInteger%2F</url>
    <content type="text"><![CDATA[Description:Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 解体思路：这道题目比较简单，难点在于溢出的判断与处理。 Solutions：Solutions 1：123456789101112131415161718int reverse(int x) &#123; const int max = 0x7fffffff; //int最大值 const int min = 0x80000000; //int最小值 long long sum = 0; while(x != 0) &#123; int temp = x % 10; sum = sum * 10 + temp; if (sum &gt; max || sum &lt; min) //溢出处理 &#123; sum = sum &gt; 0 ? max : min; return sum; &#125; x = x / 10; &#125; return sum; &#125; 将int数据类型能表示的最大值与最小值用十六进制表示出来，虽然有效，但是代码里0x7fffffff这种 hard code 不够优雅，而且容易出错。 Improved Solution 1:12345678910public int reverse(int x) &#123; long rev= 0; while( x != 0)&#123; rev= rev*10 + x % 10; x= x/10; if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; &#125; return (int) rev; &#125; int数据类型能表现的上下限以 Integer.MAX_VALUE 和 Integer.MIN_VALUE 表示，更加优雅简洁。 Solution 2:12345678910111213141516public int reverse(int x)&#123; int result = 0; while (x != 0) &#123; int tail = x % 10; int newResult = result * 10 + tail; if ((newResult - tail) / 10 != result) &#123; return 0; &#125; result = newResult; x = x / 10; &#125; return result;&#125; 原理： If overflow exists, the new result will not equal to the previous one.]]></content>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode刷题记录】1.Two Sum解法与Hashmap的应用]]></title>
    <url>%2F2017%2F04%2F24%2FSum%E8%A7%A3%E6%B3%95%E4%B8%8EHashmap%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Description:Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. My solution:12345678910 public int[] twoSum(int[] nums, int target) &#123; for(int i = 0; i &lt; nums.length; i++)&#123; for(int j = 0; j &lt; nums.length; j++)&#123; if(nums[i] + nums[j] == target &amp;&amp; i!=j)&#123; return new int [] &#123;i, j&#125;; &#125; &#125; &#125; return null;&#125; Runtime：56msYour runtime beats 9.43% of java submissions. 显然时间复杂度为O(n^2)，耗时太长，不太合理。 Better Solutions:以下为其他人提交的时间复杂度为O(n)的算法。 C++123456789101112131415161718192021vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target)&#123; //Key is the number and value is its index in the vector. unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; result; for (int i = 0; i &lt; numbers.size(); i++) &#123; int numberToFind = target - numbers[i]; //if numberToFind is found in map, return them if (hash.find(numberToFind) != hash.end()) &#123; //+1 because indices are NOT zero based result.push_back(hash[numberToFind] + 1); result.push_back(i + 1); return result; &#125; //number was not found. Put it in the map. hash[numbers[i]] = i; &#125; return result;&#125; Java12345678910111213public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; if (map.containsKey(target - numbers[i])) &#123; result[1] = i + 1; result[0] = map.get(target - numbers[i]); return result; &#125; map.put(numbers[i], i + 1); &#125; return result;&#125; Maybe The Shorest Solution123456789public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(map.containsKey(target - nums[i])) return new int[] &#123;map.get(target - nums[i]) + 1, i + 1&#125;; else map.put(nums[i], i); &#125; return null; &#125; 为什么要用Hashmap？Hashmap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，为了将时间复杂度降到O(n)，我们使用了Hashmap。 methods of Hashmap HashMap() 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 HashMap(int initialCapacity) 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap HashMap(int initialCapacity, float loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap void clear() 从此映射中移除所有映射关系。 boolean containsKey(Object key) 如果此映射包含对于指定的键的映射关系，则返回 true。 boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。 V put(K key, V value) 在此映射中关联指定值与指定键。- 在HashMap中通过get()来获取value，通过put()来插入value，ContainsKey()则用来检验对象是否已经存在。可以看出，和ArrayList的操作相比，HashMap除了通过key索引其内容之外，别的方面差异并不大。 使用HashMap后，运行速度相比于原来的275ms确实有明显提升 Runtime: 8msYour runtime beats 56.48% of java submissions.]]></content>
  </entry>
</search>
